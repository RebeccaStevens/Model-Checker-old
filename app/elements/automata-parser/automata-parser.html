<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="parser.html">
<link rel="import" href="../imports/graph.html">
<link rel="import" href="../imports/index-iterator.html">
<link rel="import" href="../imports/expression-interpreter.html">
<link rel="import" href="../imports/automaton.html">

<!--
An element for parsing/interpreting automata.
Note: This is not a visual element.

Example:<br>

    <automata-parser id="parser"></automata-parser>

@element automata-parser
-->
<script>
// jshint -W098
(function() {
  Polymer({
    is: 'automata-parser',
    properties: {
      /**
       * The PEGjs parser.
       * Used to create an object containing the idividually defined
       * definitions, constants and operations.
       *
       * @private
       */
      _initialParser: {
        type: Object,
        value: initialPEG.initialParser // created in initial-parser.js
      },
      /**
       * The PEGjs parser.
       * Used to create a parse tree that we can the interpret.
       *
       * @private
       */
      _parser: {
        type: Object,
        value: PEG.automataParser // created in parser.js
      },

      /**
       * A Map of automaton names to their definition.
       *
       * @private
       */
      _definitionsMap: {
        type: Object
      },

      /**
       * A map of variable names to their values
       *
       * @private
       */
      _variableMap: {
        type: Object
      },
      /**
       * Determines whether automata are built or not.
       *
       * @private
       */
      _buildAutomata: {
        type: Boolean
      },

      /**
       * Determines whether fair or unfair abstraction is performed.
       *
       * @private
       */
      _isFairAbstraction: {
        type: Boolean
      },

      /**
       * A Map of operations to boolean which determines whether the
       * operation passed or failed.
       *
       * @private
       */
      _operationsMap: {
        type: Object
      },

      /**
       * Current index for operations map.
       */
      _operationsIndex: {
        type: Number
      },

      /**
       * Unique identifier for operations definitions.
       *
       * @private
       */
      _operationUid: {
        type: Number
      },

      /**
       * A stack of the current composite interpretations in progress.
       *
       * @private
       */
      _compositeStack: {
        type: Array
      }
    },

    /**
     * Stores definition data.
     *
     * @private
     * @class
     * @property {!Graph} graph            - The definition's graph
     * @property {!string} type            - The type of this definition
     * @property {!array} relabel          - An array of javascript objects containing relabelling data
     * @property {!array} hidden           - An array containing actions to be hidden
     * @property {!boolean} isVisible      - Determines whether or not the graph is visualised
     * @property {!array} unprocessedNodes - An array of nodes that haven't been processed
     * @property {!number} rootId          - The id to use for the root node of this definition's graph
     */
    _Definition: function() {
      this.graph = undefined;
      this.label = undefined;
      this.relabel = undefined;
      this.hidden = undefined;
      this.isVisible = undefined;
      this.unprocessedNodes = [];
      this._rootId = undefined;
      // define the getter and setter for rootId
      // (ideally this should be done outside of this class definition)
      Object.defineProperty(this, 'rootId', {
        /**
         * Get the graph's root id.
         * If the graph hasn't been made yet, get the root id it will use.
         *
         * @returns {number} The root id
         */
        get: function() {
          // if there is a graph and it has a root
          if (this.graph && this.graph.root) {
            return this.graph.root.id;  // return the root's ids
          }
          return this._rootId;  // else return what the graph's root will be
        },
        /**
         * Set the graph's root id.
         * If the graph hasn't been made yet, set the id the graph will use for its root.
         *
         * @param {!number} val - The new id for the root
         * @returns {number} The new root id
         */
        set: function(val) {
          // if there is a graph and it has a root
          if (this.graph && this.graph.root) {
            // set and return the new id for the root
            this.graph.root.id = val;
            return this.graph.root.id;
          }
          // else set and return what the graph's root will be
          this._rootId = val;
          return this._rootId;
        }
      });
    },

    /**
     * @class
     * @param {!string} message - The error message
     */
    InterpreterException: function(message) {
      this.message = message;
      this.toString = function() {
        return 'InterpreterException: ' + this.message;
      };
    },
    /**
     *
     */
    initialParse: function(code) {
      this._resetInterpreter();
      return this._initialParser.parse(code);
    },
    /**
     * Parse the code and return the automata it defines.
     *
     * @param {!string} code - The code to parse
     * @param {!boolean} isFair - Determines whether fair or unfair abstraction is performed
     * @returns {!Automaton[]} Automata
     */
    parse: function(code, build, isFair) {
      this._resetInterpreter();
      this._buildAutomata = build;
      this._isFairAbstraction = isFair;
      var pt = this._parser.parse(code);
      return this._interpretParseTree(pt);
    },

    parseDefinition: function(code, definitionMap, build, isFair) {
      this._definitionsMap = definitionMap;
      this._buildAutomata = build;
      this._isFairAbstraction = isFair;
      var parseTree = this._parser.parse(code);
      return this._interpretParseTree(parseTree).definitions;
    },

    parseOperations: function(code, definitionMap, isFair) {
      this._definitionsMap = definitionMap;
      this._isFairAbstraction = isFair;
      var parseTree = this._parser.parse(code);
      return this._interpretParseTree(parseTree).operations;
    },

    /**
     * Reset the interpreter (reinitialise).
     *
     * @private
     */
    _resetInterpreter: function() {
      // call the private setters for these fields
      // (they're readOnly so they can't simply be set with '=')
      this._definitionsMap = {};
      this._operationsMap = {};
      this._operationsIndex = 0;
      this._operationUid = 0;
      this._compositeStack = [];
      // reset the node and edge uids in graph class
      //NodeUid.reset();
      //EdgeUid.reset();
    },

    /**
     * Interpret a parse tree generated by the parser and create an array of automata from it.
     *
     * @private
     * @param {!object[]} parseTree - A parse tree made by the parser (an array of parse tree model nodes)
     * @returns {!Automaton[]} Automata
     */
    _interpretParseTree: function(parseTree) {
      this._variableMap = parseTree.variableMap;
      parseTree.processes.forEach(function(model) {
        if (model.type === 'model') {
          this._interpretDefinitions(model);
        } else if (model.type === 'operation') {
          this._interpretOperation(model);
        } else {
          console.error('Trying to interpret invalid model type "' + model.type + '"');
        }
      }.bind(this));

      // only relabel nodes if live building is active
      if (this._buildAutomata) {
        this._relabelNodes();
      }

      return {
        definitions: this._definitionsMap,
        operations: this._operationsMap
      };
    },

    /**
     * Interpret the definitions defined in the specified model.
     *
     * @private
     * @param {!object[]} model - contains an array of definitions as well as any relabelling and hiding defined
     */
    _interpretDefinitions: function(model) {
      var globalName = this._getNameFromPTNode(model.definitions[0].name);
      this._initialiseDefinitions(model.definitions, globalName);

      // only interpret definitions if live build is active
      if (this._buildAutomata) {
        model.definitions.forEach(function(definition, i) {
          var variableMap = this._variableMap;

          // check if this definition is indexed
          if (definition.name.type === 'index') {
            this._interpretIndexedDefinition(definition.name , globalName, definition, variableMap);
          } else {
            var name = this._getNameFromPTNode(definition.name);
            name = (i !== 0) ? globalName + '.' + name : name;
            this._interpretDefinition(name, globalName, definition, variableMap);
          }
        }.bind(this));

        // process the global definition
        this._processDefinition(globalName, model);
      }
    },

    /**
     * Initialises all of the definitions defined within the specified definition to the
     * definitions map. This is to help in determining whether a reference is either
     * global or local.
     *
     * @private
     * @param {!array} definitions - array of definitions
     * @param {!string} globalName - the global name for the specified definitions
     */
    _initialiseDefinitions: function(definitions, globalName) {
      // check that there is not already a definition with the specified name
      if (this._definitionsMap[globalName] !== undefined) {
        throw new this.InterpreterException('process \'' + globalName + '\' defined more that once.');
      }

      for (var i = 1; i < definitions.length; i++) {
        if (definitions[i].name.type === 'index') {
          this._initialiseIndexedDefinitions(definitions[i].name, globalName, {});
        } else {
          var name = this._getNameFromPTNode(definitions[i].name);
          name = globalName + '.' + name;
          this._definitionsMap[name] = new this._Definition();
        }
      }

      this._definitionsMap[globalName] = new this._Definition();
    },
    /**
     *
     */
    _initialiseIndexedDefinitions: function(ptNode, globalName, variableMap) {
      if (ptNode.type === 'name') {
        var name = globalName + '.' + this._processVariables(ptNode.name, variableMap);
        this._definitionsMap[name] = new this._Definition();
      } else {
        var iterator = new IndexIterator(ptNode.index);
        while (iterator.hasNext) {
          var element = iterator.next;
          variableMap[ptNode.variable] = element;
          this._initialiseIndexedDefinitions(ptNode.process, globalName, variableMap);
        }
      }
    },
    /**
     *
     */
    _interpretDefinition: function(name, globalName, definition, variableMap) {
      var definitionMap = this._definitionsMap;
      definitionMap[name] = new this._Definition();
      definitionMap[name].graph = new Graph();
      definitionMap[name].relabel = definition.relabel;
      definitionMap[name].hidden = definition.hidden;
      definitionMap[name].isVisible = definition.isVisible;

      var rootId = definitionMap[name].rootId;
      rootId = (rootId === undefined) ? NodeUid.next : rootId;
      var root = definitionMap[name].graph.addNode(rootId);
      root.addMetaData('startNode', true);

      var referenceMap = {};
      referenceMap[name] = root;
      this._interpretProcess(definition.process, root, definitionMap, name, globalName, referenceMap, variableMap);
    },
    /**
     *
     */
    _interpretIndexedDefinition: function(ptNode, globalName, definition, variableMap) {
      if (ptNode.type === 'name') {
        var name = globalName + '.' + this._processVariables(ptNode.name, variableMap);
        this._interpretDefinition(name, globalName, definition, variableMap);
      } else {
        var iterator = new IndexIterator(ptNode.index);
        while (iterator.hasNext) {
          var element = iterator.next;
          variableMap[ptNode.variable] = element;
          this._interpretIndexedDefinition(ptNode.process, globalName, definition, variableMap);
        }
      }
    },
    /**
     * Interprets the operation defined in the specified model.
     *
     * @private
     * @param {!object} model - contains the operation along with the definitions to perform the operation on
     */
    _interpretOperation: function(model) {
      // construct definitions for this operation
      var operation = model.operator;
      var definitionMap = this._definitionsMap;
      var processes = [model.process1, model.process2];
      var defNames = [];
      var defName = 'op' + this._nextOperationUid();

      for (var i = 0; i < 2; i++) {
        var name = defName + '<process-' + i + '>';
        this._constructDefinition(name);
        this._interpretProcess(processes[i], definitionMap[name].graph.root, definitionMap, name, name, {}, {});
        defNames.push(this._popFromCompositeStack());
        this._processDefinition(name);
      }

      this._processOperation(operation, this._definitionsMap, defNames[0], defNames[1], model.input, model.isNegated, model.position);
    },

    /**
     * Interpret a parse tree process node.
     *
     * @private
     * @param {!object} process            - A parse tree process node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretProcess: function(process, extendtionNode, definitionNode, defName, globalName, referenceMap, variableMap) {
      this._interpretLocalProcess(process, extendtionNode, definitionNode, defName, globalName, referenceMap, variableMap);
      this._pushToCompositeStack(defName);
    },

    /**
     * Helper function for interpretProcess which interprets a local process.
     *
     * @private
     * @param {!object} process            - A parse tree process node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretLocalProcess: function(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      switch (process.type) {
        case 'definition':
          this._interpretInternalDefinition(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'sequence':
          this._interpretSequence(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'choice':
          this._interpretChoice(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'if-statement':
          this._interpretIfStatement(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'index':
          this._processIndex(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'parallel':
          this._interpretParallel(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'composite':
          this._interpretComposite(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'name':
          this._interpretName(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'function':
          this._interpretFunction(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'stop':
          this._interpretStop(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        case 'error':
          this._interpretError(process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
          break;
        default:
          console.error('Trying to interpret invalid process type "' + process.type + '"');
          break;
      }
    },

    /**
     * Interpret a parse tree definition node.
     *
     * @private
     * @param {!object} definition         - A parse tree definition node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretInternalDefinition: function(definition, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var name = this._getNameFromPTNode(definition);
      name = (name !== undefined) ? defName + '.' + name : defName + '<internal-process>';
      this._interpretDefinition(name, defName, definition, variableMap);
      this._processDefinition(name);
    },

    /**
     * Interpret a parse tree sequence node.
     *
     * @private
     * @param {!object} sequence           - A parse tree sequence node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretSequence: function(sequence, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var action = this._processVariables(sequence.from.action, variableMap);
      var graph = definitionMap[defName].graph;
      var node = graph.addNode(NodeUid.next);
      graph.addEdge(EdgeUid.next, extendtionNode, node, action);
      this._interpretLocalProcess(sequence.to, node, definitionMap, defName, globalName, referenceMap, variableMap);
    },

    /**
     * Interpret a parse tree choice node.
     *
     * @private
     * @param {!object} choice             - A parse tree choice node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretChoice: function(choice, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      this._interpretLocalProcess(choice.option1, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
      this._interpretLocalProcess(choice.option2, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
    },

    /**
     * Interpret a parse tree if statement node.
     *
     * @private
     * @param {!object} ifNode             - A parse tree if statement node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretIfStatement: function(ifNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var guard = interpretExpression(ifNode.guard, variableMap, true);
      // if the guard is valid then process the then statement
      if (guard) {
        this._interpretLocalProcess(ifNode.thenProcess, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
      }
      // otherwise check if an else statement was declared
      else if (ifNode.elseProcess !== undefined) {
        this._interpretLocalProcess(ifNode.elseProcess, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
      } else {
        // otherwise set extendtionNode as a terminal
        extendtionNode.addMetaData('isTerminal', 'stop');
      }
    },
    /**
     * Interpret a parse tree index node.
     *
     * @private
     * @param {!object} index              - A parse tree index node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _processIndex: function(index, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var iterator = new IndexIterator(index.index);
      while (iterator.hasNext) {
        var element = iterator.next;
        variableMap[index.variable] = element;
        this._interpretLocalProcess(index.process, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap);
      }
    },
    /**
     * Interpret a parse tree parallel node.
     *
     * @private
     * @param {!object} parallel           - A parse tree parallel node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretParallel: function(parallel, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var processes = [parallel.process1, parallel.process2];
      var graphs = [];
      for (var i = 0; i < processes.length; i++) {
        var name = defName + '<local-process-' + i + '>';
        this._constructDefinition(name);
        this._interpretProcess(processes[i], definitionMap[name].graph.root, definitionMap, name, globalName, referenceMap, variableMap);
        name = this._popFromCompositeStack();
        this._processDefinition(name);
        graphs.push(definitionMap[name].graph);
      }

      // parallel composition function is defined in 'parallel-composition.js' in the scripts folder
      var graph = parallelComposition(graphs[0], graphs[1]);
      definitionMap[defName].graph = graph;
      definitionMap[defName].graph.root = graph.root;
    },

    /**
     * Interpret a parse tree composite node.
     *
     * @private
     * @param {!object} composite          - A parse tree composite node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretComposite: function(composite, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var name = defName + '<composite>';
      this._constructDefinition(name);
      this._interpretProcess(composite.composite, definitionMap[name].graph.root, definitionMap, name, globalName, {}, variableMap);
      name = this._popFromCompositeStack();
      this._processReferences(name);
      if (name === undefined) {
        name = defName;
      }

      // check if a label has been defined
      if (composite.label !== undefined) {
        var label = this._processVariables(composite.label.action, variableMap);

        // relabel all the edges in the graph
        definitionMap[name].graph.edges.forEach(function(edge) {
          edge.label = label + '.' + edge.label;
        });
      }

      // check if a relabelling has been defined
      if (composite.relabel !== undefined) {
        this._processRelabelling(name, composite.relabel, variableMap);
      }

      if (name !== undefined && name !== defName) {
        // parallel composition function is defined in 'parallel-composition.js' in the scripts folder
        var graph = parallelComposition(definitionMap[name].graph, definitionMap[defName].graph);
        definitionMap[defName].graph = graph;
        definitionMap[defName].graph.root = graph.root;
      }
    },

    /**
     * Interpret a parse tree name node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree name node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretName: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      var references = this._getNameFromPTNode(ptNode);        // get what the extendtionNode should be referencing
      references = this._processVariables(references, variableMap);

      // check if this is a local reference
      var localReference = globalName + '.' + references;
      if (definitionMap[localReference] !== undefined) {
        references = localReference;
      }

      this._interpretReference(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap, references);
    },

    /**
     * Interprets a reference for either a name or labelled name node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree name node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     * @param {!string} references         - The reference to interpret
     */
    _interpretReference: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap, references) {
      // if there is no record of this reference yet
      if (referenceMap[references] === undefined) {
        var metaData = extendtionNode.getMetaData('references');
        if (metaData === undefined) {
          extendtionNode.addMetaData('references', [references]);
        } else {
          extendtionNode.addMetaData('references', metaData.concat(references));
        }
        referenceMap[references] = extendtionNode;                       // create a reference
        extendtionNode.addMetaData('referenceUnprocessed', true);      // mark this reference as unprocessed
        definitionMap[defName].unprocessedNodes.push(extendtionNode);   // put it in the array of unprocessed references
        // if there is no definition for this reference
        if (definitionMap[references] === undefined || definitionMap[references].graph === undefined) {
          definitionMap[references] = new this._Definition();    // create one
          definitionMap[references].rootId = extendtionNode.id;  // set what the root id should be for its graph
        }
        // if there is a definition for this reference
        else {
          extendtionNode.id = definitionMap[references].rootId;  // change the extendtionNode to use the right id
        }
      }
      // if there is a record of this reference
      else {
        definitionMap[defName].graph.combineWith(referenceMap[references].graph);
        definitionMap[defName].graph.mergeNodes([referenceMap[references].id, extendtionNode.id]);
      }
    },

    /**
     * Interprets a parse tree abstraction node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree abstraction node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretFunction: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      this._interpretProcess(ptNode.process, extendtionNode, definitionMap, defName, defName, referenceMap, variableMap);

      var name = this._popFromCompositeStack();
      if (name === undefined) {
        name = defName;
      } else {
        this._processReferences(defName);
      }

      // check if there is any edges to relabel
      if (ptNode.relabel !== undefined) {
        this._processRelabelling(name, ptNode.relabel);
      }

      // check if there is any edges to hide
      if (ptNode.hidden !== undefined) {
        this._processHiding(name, ptNode.hidden);
      }

      var graph = definitionMap[name].graph;
      var type = ptNode.func;
      if (type === 'abstraction') {
        // abstraction function defined in 'abstraction.js' in scripts folder
        definitionMap[defName].graph = abstraction(graph, this._isFairAbstraction);
      } else if (type === 'simplification') {
        // simplification function is defined in 'bisimulation.js' in scripts folder
        definitionMap[defName].graph = simplification(graph);
      }
      // if any other functions are required, add another else if statement to this one

      extendtionNode.id = definitionMap[defName].graph.root.id;
    },

    /**
     * Interpret a parse tree stop node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree stop node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretStop: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      extendtionNode.addMetaData('isTerminal', 'stop');
    },

    /**
     * Interpret a parse tree error node.
     *
     * @private
     * @param {!object} ptNode             - A parse tree error node
     * @param {!Graph.Node} extendtionNode - The node in the graph to build on from
     * @param {!object} definitionMap      - The definition map being used
     * @param {!string} defName            - The name of the current definition
     * @param {!object} referenceMap       - The reference map that store references already known about
     */
    _interpretError: function(ptNode, extendtionNode, definitionMap, defName, globalName, referenceMap, variableMap) {
      // add a deadlock edge from extendtion node
      var graph = definitionMap[defName].graph;
      var node = graph.addNode(NodeUid.next);
      var edge = graph.addEdge(EdgeUid.next, extendtionNode, node, '');
      edge.deadlockEdge();
      node.addMetaData('isTerminal', 'error');
    },

    /**
     * Checks the specified aciton to see if any variables or expressions are referenced
     * in it and replaces these references with their corresponding values from the
     * variable map.
     *
     * @private
     * @param {string} action - the action to process
     * @param {object} variableMap - a map of variable names to their values
     * @returns {string} - the processed action
     */
    _processVariables: function(action, variableMap) {
      var regex = '[\$][v<]*[a-zA-Z0-9]*[>]*';
      var match = action.match(regex);

      // continue to process while matches can still be found
      while (match !== null) {
        var expression = interpretExpression(variableMap[match[0]], variableMap);
        action = action.replace(match[0], expression);
        match = action.match(regex);
      }

      return action;
    },

    /**
     * Interpret a parse tree operation node.
     *
     * @private
     * @param {!object} operation - a parse tree operation node
     * @param {!object} definitionMap - the definition map being used
     * @param {!string} defName1 - the name of the first definition
     * @param {!string} defName2 - the name of the second definition
     * @param {!string} input - a text representation of the input
     * @param {!boolean} isNegated - whether or not this operation is negated
     * @param {!object} position - the position of the operation in the code
     */
    _processOperation: function(operation, definitionMap, defName1, defName2, input, isNegated, position) {
      var result = false;
      switch (operation) {
        case 'bisimulation':
          result = this._processBisimulation(definitionMap, defName1, defName2, input);
          break;
        default:
          console.error('Trying to interpret invalid process type "' + process + '"');
          break;
      }

      // negate the result if the not operator was used
      if (isNegated) {
        result = !result;
      }
      var i = this._nextOperationsIndex();
      this._operationsMap[i] = {input: input, result: result, position: position};
    },

    /**
     * Processes a bisimulation operation between the defined definitions and returns
     * whether both processes are bisimular or not.
     *
     * @private
     * @param {!object} definitionMap - a map of definition names to definition processes
     * @param {!string} defName1 - the first definition name
     * @param {!string} defName2 - the second definition name
     * @returns {!boolean} - true if the two definitions are bisimular, otherwise false
     */
    _processBisimulation: function(definitionMap, defName1, defName2) {
      var graph1 = definitionMap[defName1].graph;
      var graph2 = definitionMap[defName2].graph;
      // isEquivalent function is defined in 'bisimulation.js' in scripts folder
      return isEquivalent([graph1, graph2]);
    },

    /**
     * Constructs and returns an empty definition.
     *
     * @private
     * @param {!string} defName - the name of the definition to construct
     * @param {!string} type - the type of definition
     * @param {!object} relabel - either an array of relabelling objects or undefined
     * @param {!object} hidden - either an array of actions to hide or undefined
     * @param {!boolean} isVisible - whether or not this definition is to be visualised
     */
    _constructDefinition: function(defName, type, relabel, hidden, isVisible) {
      this._definitionsMap[defName] = new this._Definition();
      this._definitionsMap[defName].graph = new Graph();
      var rootId = this._definitionsMap[defName].rootId;
      var root = this._definitionsMap[defName].graph.addNode(
        rootId === undefined ? NodeUid.next : rootId
      );
      root.addMetaData('startNode', true);
      this._definitionsMap[defName].type = type;
      this._definitionsMap[defName].relabel = relabel;
      this._definitionsMap[defName].hidden = hidden;
      this._definitionsMap[defName].isVisible = isVisible;
    },
    /**
     * Runs the processing of references, parallel composition, relabelling and hiding for
     * the specified definition.
     *
     * @private
     * @param {!string} defName - the definition to process
     */
    _processDefinition: function(defName) {
      this._processReferences(defName);
      this._processLabelling(defName);
      this._processRelabelling(defName);
      this._processHiding(defName);
    },

    /**
     * Process all the unprocessed references for the specified definition.
     *
     * @private
     * @param {!string} defName - the name of the definition to process
     */
    _processReferences: function(defName) {
      var prevReferences = defName;   // for correct error messages
      // while it has un processed nodes
      while (this._definitionsMap[defName].unprocessedNodes.length > 0) {
        var definition = this._definitionsMap[defName];
        var len = this._definitionsMap[defName].unprocessedNodes.length;
        var references;
        // loop through all the unprocessed nodes
        // (only the ones that were marked as un processed when the while loop started,
        // not any new unprocessed nodes that were added)
        for (var i = 0; i < len; i++) {
          var node = definition.unprocessedNodes[i];
          var refs = node.getMetaData('references');
          for (var j = 0; j < refs.length; j++) {
            references = refs[j];

            // check whether or not the automaton that this node is referencing actual exist.
            if (this._definitionsMap[references] === undefined || this._definitionsMap[references].graph === undefined) {
              throw new this.InterpreterException('unknown automaton "' + references + '" referenced in "' + prevReferences + '".');
            }

            var refGraph = this._definitionsMap[references].graph;
            var refNodes = refGraph.nodes;
            // set the current nodes id to the root of the reference graph
            node.id = refGraph.root.id;
            // add the nodes and edge from the referenced graph in to this one
            definition.graph.combineWith(refGraph);
            // find all the unprocessed nodes that we are adding to this graph
            // and add them to the array of unprocessed nodes
            for (var k = 0; k < refNodes.length; k++) {
              var gRefNode = definition.graph.getNode(refNodes[k].id);
              if (gRefNode.getMetaData('referenceUnprocessed')) {
                definition.unprocessedNodes.push(gRefNode);
              }
            }
            node.deleteMetaData('referenceUnprocessed'); // this node has now been processed
          }
        }
        // remove all the nodes we just processed from the unprocessed nodes array
        definition.unprocessedNodes.splice(0, len);
        prevReferences = references;
      }

      // make sure that the root of the graph is the start node
      this._definitionsMap[defName].graph.root.addMetaData('startNode', true);
    },

    /**
     * Process the labelling of transitiosn for the specified definition.
     * This labels each edge in the definition's graph as:
     *     <label>.<edge>
     *
     * @private
     * @param {!string} defName - the definition to perform labelling for
     */
    _processLabelling: function(defName) {
      var label = this._definitionsMap[defName].label;
      if (label !== undefined) {
        var edges = this._definitionsMap[defName].graph.edges;
        // relabel all the edges in the definition
        edges.forEach(function(edge) {
          var newLabel = label + '.' + edge.label;
          edge.label = newLabel;
        }.bind(this));
      }
    },

    /**
     * Process the relabelling of transitions for the specified definition.
     *
     * @private
     * @param {!string} defName - the definition to perform relabelling for
     */
    _processRelabelling: function(defName, relabel) {
      relabel = (relabel === undefined) ? this._definitionsMap[defName].relabel : relabel;
      if (relabel !== undefined) {
        relabel = this._processRelabellingSet(relabel, this._variableMap);
        // get an array of edges in the current graph
        var edges = this._definitionsMap[defName].graph.edges;
        // check each edge to see if it needs to be updated
        edges.forEach(function(edge) {
          for (var i = 0; i < relabel.length; i++) {
            // only update the edge if it needs to be relabelled
            var oldLabel = relabel[i].old;
            var newLabel = relabel[i].new;
            if (oldLabel === edge.label) {
              edge.label = newLabel;
            }
          }
        }.bind(this));
      }
    },

    /**
     * Processes and returns the set of relabelling objects.
     *
     * @private
     * @param {!object} set - the set of relabelling objects to process
     * @returns {!object} processed set
     */
    _processRelabellingSet: function(set) {
      var result = [];
      for (var i = 0; i < set.length; i++) {
        var newLabel = this._processVariables(set[i].newLabel, this._variableMap);
        var oldLabel = this._processVariables(set[i].oldLabel, this._variableMap);
        result.push({new: newLabel, old: oldLabel});
      }

      return result;
    },

    /**
     * Process the hiding of transitions for the specified definition.
     *
     * @private
     * @param {!string} defName - the definition to perform relabelling for
     */
    _processHiding: function(defName, hidden) {
      hidden = (hidden === undefined) ? this._definitionsMap[defName].hidden : hidden;
      if (hidden !== undefined) {
        var type = hidden.type;
        var set = this._processSet(hidden.set);
        // get an array of edges in the current graph
        var edges = this._definitionsMap[defName].graph.edges;
        // check each edge to see if it needs to be updated
        edges.forEach(function(edge, index) {
          var contains = _.contains(set, edge.label);
          if ((type === 'includes' && contains) || (type === 'excludes' && !contains)) {
            // only updates the edge if it needs to be hidden
            edge.hideEdge();
          }
        }.bind(this));
      }
    },

    /**
     * Processes and returns the set of hiding objects.
     *
     * @private
     * @param {!object} set - the set of hiding objects to process
     * @returns {!object} processed set
     */
    _processSet: function(set) {
      var tempSet = [];
      for (var i = 0; i < set.length; i++) {
        // check whether this element is either a string or an index object
        if (typeof(set[i]) === 'string') {
          tempSet.push(this._processVariables(set[i]));
        } else {
          var iterator = new IndexIterator(set[i].index);
          var variableMap = {};
          while (iterator.hasNext) {
            var element = iterator.next;
            variableMap[set[i].variable] = element;
            tempSet.push(this._processVariables(set[i].process, variableMap));
          }
        }
      }

      return tempSet;
    },

    /**
     * Processes and returns the specified range value. Checks to see if the range
     * has been previously defined, references valid constants and that it is not
     * invalid (the start of the range is greater than the end of the range).
     *
     * @private
     * @param {!object} range - the range to be processed
     * @param {!string} defName - the name of the range
     * @returns {!object} - the processed range
     */
    _processRange: function(range, defName, variableMap) {
      variableMap = (variableMap === undefined) ? this._variableMap : variableMap;

      // assign constant values to start or end points if necessary
      var points = [range.start, range.end];

      for (var i = 0; i < points.length; i++) {
        if (typeof(points[i]) !== 'number') {
          points[i] = interpretExpression(points[i], variableMap);
        }
      }

      // update the range
      range.start = points[0];
      range.end = points[1];

      // make sure that start of range is less than then end
      if (range.start >= range.end) {
        throw new this.InterpreterException('Start of range greater than or equal to end of range for range "' + defName + '".');
      }

      range.type = 'range';
      return range;
    },

    /**
     * Relabel the nodes in each automata definition.
     * Done by performing a depth first search of the graph.
     *
     * @private
     * @param {boolean} showRefs - If set will prefix reference nodes' labels with the automaton they reference
     * @param {boolean} useIds   - If set will use the nodes' id as the label
     */
    _relabelNodes: function(showRefs, useIds) {
      var automata = this._getAutomataFromDefinitionsMap();
      for (var key in automata) {
        key = automata[key];
        var label = 0;
        var visitedNodes = {};
        var fringe = [];
        fringe.push(this._definitionsMap[key].graph.root);
        while (fringe.length > 0) {
          var node = fringe.shift();
          // if already visited
          if (visitedNodes[node.id]) {
            continue; // don't do anything with this node and start on the next one
          }
          visitedNodes[node.id] = node;   // mark as visited
          // label the node
          var ref = node.getMetaData('references');
          if (showRefs && ref && ref !== this.name) {
            node.label = ref + ':';
          } else {
            node.label = '';
          }
          node.label += useIds ? 'n' + node.id : label++;
          // loop through all the current node's neighbors
          var neighbors = node.neighbors;
          for (var i in neighbors) {
            // if neighbor is unvisited
            if (!visitedNodes[neighbors[i].id]) {
              fringe.push(neighbors[i]);
            }
          }
        }
      }
    },

    /**
     * Get the name from a parse tree name node.
     *
     * @private
     * @param {!object} ptNode - A parse tree name node
     * @returns {string}
     */
    _getNameFromPTNode: function(ptNode) {
      if (ptNode === undefined) {
        return undefined;
      }

      var name = this._getNameFromPTNode(ptNode.name);
      if (name === undefined) {
        return ptNode.name;
      }
      return name;
    },

    /**
     * Returns the next free index in the operations map.
     *
     * @private
     * @returns {!integer} - next available index
     */
    _nextOperationsIndex: function() {
      var index = this._operationsIndex;
      this._operationsIndex = index + 1;
      return index;
    },

    /**
     * Returns the next unique operation uid.
     *
     * @private
     * @returns {!string} - next operation uid
     */
    _nextOperationUid: function() {
      var next = this._operationUid;
      this._operationUid = next + 1;
      return '' + next;
    },

    /**
     * Pushes the specified definition name to the composite stack.
     *
     * @private
     * @param {!string} name - definition name
     */
    _pushToCompositeStack: function(name) {
      var stack = this._compositeStack;
      stack.push(name);
      this._compositeStack = stack;
    },

    /**
     * Pops the next definition name from composite stack.
     *
     * @private
     * @returns {!string} the last definition name added to the composite stack
     */
    _popFromCompositeStack: function() {
      var stack = this._compositeStack;
      var name = stack.pop();
      this._compositeStack = stack;
      return name;
    },

    /**
     * Returns the keys for all the automata defined in the definitions map.
     *
     * @private
     * @returns {!array} - an array of keys
     */
    _getAutomataFromDefinitionsMap: function() {
      var automata = [];
      for (var key in this._definitionsMap) {
        if (this._definitionsMap[key].graph !== undefined) {
          automata.push(key);
        }
      }

      return automata;
    }
  });
})();
</script>
