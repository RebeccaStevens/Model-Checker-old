<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../styles/shared-styles.html">
<link rel="import" href="../imports/ace.html">

<!--
An element for accepting text content from the user.

Example:<br>

    <text-editor></text-editor>

@element text-editor
@demo text-editor/demo/index.html
-->
<dom-module id="text-editor">
  <style include="shared-styles"></style>
  <style>
    :host {
      display: block;
      position: relative;
    }
    paper-material {
      padding: 0;
      @apply(--layout-fit);
    }
    #editor {
      box-sizing: border-box;
      position: absolute;
      top: 0;
      right: 0;
      bottom: 0;
      left: 0;
    }
  </style>
  <template>
    <paper-material>
      <div id="editor"></div>
    </paper-material>
  </template>
</dom-module>
<script>
  // jshint -W106
  (function() {
    Polymer({
      is: 'text-editor',

      /**
       * Fired when the text in the editor is changed.
       * When the user is typing, multiple events will be debounced into one.
       *
       * @event code-changed
       */

      properties: {
        /**
         * If true the editor will be brought into focus automatically when the elements is attached to the dom.
         */
        autofocus: {
          type: Boolean,
          value: false
        },

        /**
         * The ace editor object
         */
        _editor: {
          type: Object,
          value: function(){
            var editor = ace.edit(this.$.editor);
            editor.setTheme('ace/theme/github');
            editor.getSession().setMode('ace/mode/plain_text'); // syntax highlighting
            return editor;
          },
          readOnly: true
        }
      },

      /**
       * Constructs and returns an annotation.
       *
       * @param {!integer} line - the line number to put annotation on
       * @param {!string} text - the text to put in the annotation
       * @param {!string} type - the type of annotation to place
       * @returns {!object} - an annotation object
       */
      constructAnnotation: function(line, text, type) {
        var annotation = {
          row: line,
          column: 2,
          text: text,
          type: type
        };

        return annotation;
      },

      /**
       * Sets the annotations of the editor to those specified in the array.
       *
       * @param {!array} annotations - an array of annotations
       */
      setAnnotations: function(annotations) {
        this._editor.session.setAnnotations(annotations);
      },

      /**
       * Bring this element into focus
       */
      focus: function(){
        this._editor.focus();
      },

      /**
       * Called when the element has been created, but before property values are set and local DOM is initialized.
       */
      created: function() {

        // Define `this.code`
        // Defined here instead of in the properties object as we want control over the getter and setter

        /**
         * The code in the editor.
         *
         * @type {String}
         */
        Object.defineProperty(this, 'code', {
          get: function() {
            return this._editor.getValue();
          },
          set: function(val) {
            return this._editor.setValue(val, 1);
          }
        });
      },

      /**
       * Called after property values are set and local DOM is initialized.
       */
      ready: function() {
        this._editor.$blockScrolling = Infinity;   // disable scrolling warning messgae

        // fire a 'code-changed' event when the text editor's content changes
        this._editor.addEventListener('change', function(e) {
          this.fire('code-changed', {originalEvent: e});
        }.bind(this));
      },

      /**
       * Called after the element is attached to the document.
       */
      attached: function() {
        if(this.autofocus) {
          this.async(function() {
              this.focus();
          }, 100);
        }
      },

      /**
       * Called when one of the element's attributes is changed.
       */
      attributeChanged: function(attr, oldVal, newVal) {
        if(!this.isAttached){
            return false;
        }
        switch(attr){
          case 'theme':
            this._editor.setTheme(newVal);
            break;
          case 'mode':
            this._editor.getSession().setMode(newVal);
            break;
          case 'fontsize':
            this._editor.setFontSize(newVal);
            break;
          case 'softtabs':
            this._editor.getSession().setUseSoftTabs(newVal);
            break;
          case 'tabsize':
            this._editor.getSession().setTabSize(newVal);
            break;
          case 'readonly':
            this._editor.setReadOnly(newVal);
            break;
          case 'wrapmode':
            this._editor.getSession().setUseWrapMode(newVal !== null);
            break;
        }
      }
    });
  })();
</script>
