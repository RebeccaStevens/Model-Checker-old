<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/sm3-resizable/sm3-resizable.html">
<link rel="import" href="../../styles/shared-styles.html">
<link rel="import" href="../imports/dagre-d3.html">

<!--
An element for rendering out an automaton.

Example:<br>

    <automata-visualisation name="My Automaton" graph="[[graph]]"></automata-visualisation>

### Styling

The following custom properties and mixins are available for styling:

Custom property | Description | Default
----------------|-------------|----------
`--automata-visualisation-height` | The initial height of the element | `100%`
`--automata-visualisation-min-height` | The min-height of the element |
`--automata-visualisation-name-color` | The color of the name of the automaton | `black`
`--automata-visualisation-name-font-size` | The font size of the name of the automaton | `12pt`
`--automata-visualisation-node-label-color` | The color of all node labels | `black`
`--automata-visualisation-node-fill` | The fill color of all nodes | `lightgrey`
`--automata-visualisation-node-stroke` | The stroke color of all nodes | `black`
`--automata-visualisation-node-stroke-width` | The stroke width of all nodes | `3px`
`--automata-visualisation-node-inner-stroke-width` | The inner stroke width of terminal nodes | `2px`
`--automata-visualisation-edge-label-color` | The color of the edge labels | `black`
`--automata-visualisation-edge-fill` | The fill color of the edges | `blue`
`--automata-visualisation-edge-stroke` | The stroke color of the edges | `black`
`--automata-visualisation-edge-stroke-width` | The stroke width of the edges | `2px`
`--automata-visualisation-stop-node-stroke` | The stroke color of stop nodes | `green`
`--automata-visualisation-stop-node-inner-stroke` | The inner stroke color of stop nodes | `green`
`--automata-visualisation-error-node-stroke` | The stroke color of error nodes | `red`
`--automata-visualisation-error-node-inner-stroke` | The inner stroke color of error nodes | `red`
`--automata-visualisation-highlighted-node-fill` | The fill color of the highlighted node | `yellow`
`--automata-visualisation-highlighted-edge-fill` | The fill color of the highlighted edge | `blue`
`--automata-visualisation-highlighted-edge-stroke` | The stroke color of the highlighted edge | `blue`
`--automata-visualisation-highlighted-edge-stroke-width` | The stroke width of the highlighted edge | `2px`
`--automata-visualisation-name` | A mixin applied to the automaton's name | {}
`--automata-visualisation-node` | A mixin applied to all nodes | {}
`--automata-visualisation-node-label` | A mixin applied to all node labels | {}
`--automata-visualisation-edge` | A mixin applied to all edges | {}
`--automata-visualisation-edge-label` | A mixin applied to all edge labels | {}
`--automata-visualisation-terminal-node` | A mixin applied to all terminal nodes | {}
`--automata-visualisation-terminal-node-inner` | A mixin applied to the inner of terminal nodes | {}
`--automata-visualisation-terminal-node-label` | A mixin applied to the terminal node labels | {}
`--automata-visualisation-stop-node` | A mixin applied to all stop nodes | {}
`--automata-visualisation-stop-node-inner` | A mixin applied to the inner of stop nodes | {}
`--automata-visualisation-stop-node-label` | A mixin applied to the stop node labels | {}
`--automata-visualisation-error-node` | A mixin applied to all error nodes | {}
`--automata-visualisation-error-node-inner` | A mixin applied to the inner of error nodes | {}
`--automata-visualisation-error-node-label` | A mixin applied to the error node labels | {}
`--automata-visualisation-reference-node` | A mixin applied to all reference nodes | {}
`--automata-visualisation-reference-node-label` | A mixin applied to the reference node labels | {}
`--automata-visualisation-highlighted-node` | A mixin applied to the highlighted node | {}
`--automata-visualisation-highlighted-node-label` | A mixin applied to the highlighted node's label | {}
`--automata-visualisation-highlighted-edge` | A mixin applied to the highlighted edge | {}

@element automata-visualisation
@demo demo/index.html
-->
<dom-module id="automata-visualisation">
  <style include="shared-styles"></style>
  <style>
    :host {
      color: #6C7A89;
      position: relative;
    }
    sm3-resizable {
      width: 100% !important;
      height: var(--automata-visualisation-height, 100%);
      min-height: var(--automata-visualisation-min-height);
      --sm3-resizable-handle-s: {
        bottom: 0;
        left: 8px;
        right: 8px;
        height: 16px;
      };
    }
    paper-material {
      @apply(--layout-fit);
    }
    #svg-parent {
      @apply(--layout-fit);
      margin: 4px 4px 4px 4px;
    }
    #svg {
      width: 100%;
      height: 100%;
    }
    #name {
      position: absolute;
      top: 8px;
      left: 8px;
      color: var(--automata-visualisation-name-color, black);
      font-size: var(--automata-visualisation-name-font-size, 12pt);
      @apply(--automata-visualisation-name);
    }
    .node circle.outer {
      fill: var(--automata-visualisation-node-fill, lightgrey);
      stroke: var(--automata-visualisation-node-stroke, black);
      stroke-width: var(--automata-visualisation-node-stroke-width, 3px);
      @apply(--automata-visualisation-node);
    }
    .node circle.inner {
      fill: transparent;
      stroke: transparent;
      stroke-width: var(--automata-visualisation-node-inner-stroke-width, 2px);
    }
    .node .label {
      font-size: 22px;
      fill: var(--automata-visualisation-node-label-color, black);
      @apply(--automata-visualisation-node-label);
    }
    .node.start {
      transform: scale(0);
      display: none;
    }
    .node.terminal circle.outer {
      @apply(--automata-visualisation-terminal-node);
    }
    .node.terminal circle.inner {
      @apply(--automata-visualisation-terminal-node-inner);
    }
    .node.terminal .label {
      @apply(--automata-visualisation-terminal-node-label);
    }
    .node.stop circle.outer {
      stroke: var(--automata-visualisation-stop-node-stroke, green);
      @apply(--automata-visualisation-stop-node);
    }
    .node.stop circle.inner {
      stroke: var(--automata-visualisation-stop-node-inner-stroke, green);
      @apply(--automata-visualisation-stop-node-inner);
    }
    .node.stop .label {
      @apply(--automata-visualisation-stop-node-label);
    }
    .node.error circle.outer {
      stroke: var(--automata-visualisation-error-node-stroke, red);
      @apply(--automata-visualisation-error-node);
    }
    .node.error circle.inner {
      stroke: var(--automata-visualisation-error-node-inner-stroke, red);
      @apply(--automata-visualisation-error-node-inner);
    }
    .node.error .label {
      @apply(--automata-visualisation-error-node-label);
    }
    .node.reference circle.outer {
      @apply(--automata-visualisation-reference-node);
    }
    .node.reference .label {
      @apply(--automata-visualisation-reference-node-label);
    }
    .node.highlighted circle.outer {
      fill: var(--automata-visualisation-highlighted-node-fill, yellow);
      @apply(--automata-visualisation-highlighted-node);
    }
    .node.highlighted .label {
      @apply(--automata-visualisation-highlighted-node-label);
    }
    .edgePath path {
      fill: var(--automata-visualisation-edge-fill, black);
      stroke: var(--automata-visualisation-edge-stroke, black);
      stroke-width: var(--automata-visualisation-edge-stroke-width, 2px);
      @apply(--automata-visualisation-edge);
    }
    .edgeLabel {
      font-size: 20px;
      fill: var(--automata-visualisation-edge-label-color, black);
      @apply(--automata-visualisation-edge-label);
    }
    .edgePath.highlighted path {
      fill: var(--automata-visualisation-highlighted-fill, blue);
      stroke: var(--automata-visualisation-highlighted-edge-stroke, blue);
      stroke-width: var(--automata-visualisation-highlighted-edge-stroke-width, 2px);
      @apply(--automata-visualisation-highlighted-edge);
    }
  </style>

  <template>
    <sm3-resizable id="resizer" handle-s on-sm3-resizable-resized="_onResize">
      <paper-material>
        <div id="svg-parent">
          <svg id="svg"></svg>
        </div>
        <div id="name">[[name]]</div>
      </paper-material>
    </sm3-resizable>
  </template>
</dom-module>

<script>
  (function() {
    'use strict';

    Polymer({
      is: 'automata-visualisation',

      properties: {
        /**
        * The name of the automaton.
        */
        name: {
          type: String,
          value: 'Unnamed Automaton'
        },

        /**
        * The graph to render.
        */
        graph: {
          type: Object,
          value: function() {
            return { nodes: [], edges: [] };
          }
        },

        /**
         * The arrowhead style.
         *
         * either `normal`, `vee`, or `undirected`.
         */
        arrowhead: {
          type: String,
          value: 'normal'
        },

        /**
         * The dagreD3 graph that is rendered.
         */
        _automaton: Object
      },

      ready: function() {
        // mark the svg element as a scoped subtree so that dom modification by dagreD3 are styled correctly
        this.scopeSubtree(this.$.svg, true);
      },

      observers: [
        '_onGraphUpdated(graph.nodes, graph.edges)'
      ],

      /**
       * Highlight the specified node.
       *
       * @param {!string} id - The id of the node to highlight
       */
      setHighlightedNode: function(id) {
        this.unsetHighlightedNode();
        var node = Polymer.dom(this.$.svg).querySelector('#n'+id);
        if (node) {
          node.classList.add('highlighted');
        }
      },

      /**
       * Highlight the specified edge.
       *
       * @param {!string} id - The id of the edge to highlight
       */
      setHighlightedEdge: function(id) {
        this.unsetHighlightedEdge();
        var edge = Polymer.dom(this.$.svg).querySelector('#e'+id);
        if (edge) {
          edge.classList.add('highlighted');
        }
      },

      /**
       * De-highlight all nodes.
       */
      unsetHighlightedNode: function() {
        Polymer.dom(this.$.svg).querySelectorAll('.node.highlighted').forEach(function(n) {
          n.classList.remove('highlighted');
        });
      },

      /**
       * De-highlight all edges.
       */
      unsetHighlightedEdge: function() {
        Polymer.dom(this.$.svg).querySelectorAll('.edgePath.highlighted').forEach(function(n) {
          n.classList.remove('highlighted');
        });
      },

      /**
       * Render the automaton.
       */
      render: function() {
        // remove the child nodes (the old graph) from the svg element
        for(var i=0; i<this.$.svg.children.length; i++){
          Polymer.dom(this.$.svg).removeChild(this.$.svg.children[i]);
        }

        // create a new directed graph
        this._automaton = new dagreD3.graphlib.Graph({ multigraph: true });
        this._automaton.setGraph({
          rankdir: 'LR',
          ranksep: 75,
          marginx: 0,
          marginy: 0
          // nodesep: 0
          // edgesep: 0
        });

        // Note:
        // dagreD3 sorts the nodes given to it alphabetically then the root node is
        // concider to be first node after this sorting.
        // In order to specifie the actual start node, create a node that will be
        // first after sorting then create a edge from it to the "visual" start node

        // this is the node in `this.graph.nodes` that is marked as the start node
        var visualStartNode;

        // create the actual start node
        this._automaton.setNode(
          '0',
          {
            label: '',
            shape: 'circle',
            class: 'start'
          });

        // add the nodes to the graph
        this.graph.nodes.forEach(function(node) {
          // the classes for this node
          var styleClasses = '';

          if (node.getMetaData('startNode')) {
            visualStartNode = node;
          }

          var terminal = node.getMetaData('isTerminal');
          if (terminal) {
            styleClasses += ' terminal ' + terminal;
          }

          var ref = node.getMetaData('references');
          if (ref && ref !== this.name) {
            styleClasses += ' reference';
          }

          // add the node to the graph
          this._automaton.setNode(
            'n' + node.id,
            {
              label: node.label,
              shape: 'automatonnode',
              class: styleClasses.trim(),
              id: 'n' + node.id
            });

        }.bind(this));

        // Default to assigning a new object as a label for each new edge.
        this._automaton.setDefaultEdgeLabel(function() {
          return {};
        });

        // create an edge from the actual start node to the visual start node
        this._automaton.setEdge(
          '0',
          'n' + visualStartNode.id,
          {
             label: '',
             lineInterpolate: 'basis',
             arrowhead: this.arrowhead,
             id: 'startEdge'
          },
          'startEdge');

        // add the edges to the graph
        //  - the from node's label
        //  - the to node's label
        //  - the edge's extra data (could be label, width, height, etc.)
        this.graph.edges.forEach(function(edge) {
          var label = edge.label || '\u03B5';

          if (edge.isHidden) {
            label = '\u03C4';
          }
          else if (edge.isDeadlock) {
            label = '\u03B4';
          }

          // add the edge to the graph
          this._automaton.setEdge(
            'n'+edge.from.id,
            'n'+edge.to.id,
            {
              label: label,
              lineInterpolate: 'basis',
              arrowhead: this.arrowhead,
              id: 'e' + edge.id
            },
            edge.id);

        }.bind(this));

        var svg = d3.select(this.$.svg);
        var svgGroup = svg.append('g');       // add a new group node to the svg element for the new graph
        var render = this._createRenderer();    // create the renderer

        // run the renderer, which will render the graph and insert it into the svgGroup.
        // Note: trying call render method with a node (first arg) that is not yet in the Dom will cause an error
        render(svgGroup, this._automaton);

        this._center(svg, svgGroup);
        this.fire('automata-visualisation-rendered');
      },

      /**
       * Called when `#resizer` is resized
       */
      _onResize: function() {
        this.debounce('automata-visualisation-resize', function() {
          var svg = d3.select(this.$.svg);
          var svgGroup = svg.select('g');
          this._center(svg, svgGroup);
        }, 300);
      },

      /**
       * Called when `graph` is updated (the nodes or edges change)
       */
      _onGraphUpdated: function() {
        this.debounce('automata-visualisation-render', function() {
          this.render();  // re-render the automaton (this will also do the first render)
        });
      },

      /**
       * Create a dagreD3 renderer.
       */
      _createRenderer: function() {
        var render = new dagreD3.render();    // create the renderer

        // define the 'automatonnode' shape
        render.shapes().automatonnode = function(parent, bbox, node) {
          var r = 34;

          parent.insert('circle', ':first-child')
            .attr('r', r * 0.80)
            .attr('class', 'inner')
            .attr('transform', 'translate(0,0)');

          var shapeSvg = parent.insert('circle', ':first-child')
            .attr('r', r)
            .attr('class', 'outer')
            .attr('transform', 'translate(0,0)');

          node.intersect = function(point) {
            return dagreD3.intersect.circle(node, r+4, point);  // make the intersect slightly larger for visual effect
          };

          return shapeSvg;
        };

        return render;
      },

      /**
       * Center the contents of an svg.
       *
       * @param {!Object} svg - the d3 svg to center the contents
       * @param {!Object} svgGroup - the d3 svg group being centered
       */
      _center: function(svg, svgGroup) {

        // Get the SVG's attrs as well as the automaton's attrs
        var svgStyle = window.getComputedStyle(svg[0][0]);
        var svgWidth = Number.parseFloat(svgStyle.getPropertyValue('width'));
        var svgHeight = Number.parseFloat(svgStyle.getPropertyValue('height'));
        var automatonData = this._automaton.graph();

        // Compute the scale where the automaton will fit
        var computedInitialScaleForWitdth = svgWidth / (automatonData.width * 1.1);
        var computedInitialScaleForHeight = svgHeight / (automatonData.height * 1.1);
        var initialScale = Math.min(1, computedInitialScaleForHeight, computedInitialScaleForWitdth);

        // limit the zoom and pan behaviour
        var zoom = d3.behavior.zoom().scaleExtent([0.5, 5]).on('zoom', function() {
          // the raw translate value [x, y] from the mouse coords
          var t = d3.event.translate;
          // set our modified scale to reflect the initial scale in addition to the user's scale changes
          var s = initialScale + d3.event.scale - 1;

          // the maximum left value
          var txl = Math.max(0, Math.min(svgWidth - this._automaton.graph().width * s, t[0]));
          // the maximum right value
          var txr = Math.min(svgWidth - this._automaton.graph().width * s , Math.max(0, t[0]));
          // the ultimate x value, souch that it is bounded to txl and txr
          var tx = Math.min(txl, Math.max(txr, t[0]));

          // the maximum top value
          var tyl = Math.max(0, Math.min(svgHeight - this._automaton.graph().height * s, t[1]));
          // the maximum bottom value
          var tyr = Math.min(svgHeight - this._automaton.graph().height * s , Math.max(0, t[1]));
          // the ultimate y value, souch that it is bounded to txl and txr
          var ty = Math.min(tyl, Math.max(tyr, t[1]));

          // the ultimate translation array, bounded
          var boundedTranslate = [tx, ty];

          // scale and translate
          svgGroup.attr('transform',
            'translate(' + boundedTranslate[0] + ',' + boundedTranslate[1] + ')' +
            'scale(' + s + ')');
        }.bind(this));

        // Update the svg such that it's events call our bounding function
        svg.call(zoom);

        // Calculate the offsets required to be in center
        var xCenterOffset = (svgWidth - automatonData.width * initialScale) / 2;
        var yCenterOffset = (svgHeight - automatonData.height * initialScale) / 2;

        // Center the graph
        zoom.translate([xCenterOffset, yCenterOffset]).event(svg);

        // Center the labels in the nodes
        var nodeLabels = svg[0][0].querySelectorAll('g.node g.label g text tspan');
        for (var i = 0; i < nodeLabels.length; i++) {
          nodeLabels[i].setAttribute('x', '0');
          nodeLabels[i].setAttribute('dx', '-1px');
          nodeLabels[i].setAttribute('dy', '0.8em');
        }
      }
    });
  })();
</script>
