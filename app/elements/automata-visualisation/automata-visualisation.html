<link rel="import" href="../../bower_components/polymer/polymer.html">
<link rel="import" href="../../bower_components/iron-flex-layout/iron-flex-layout.html">
<link rel="import" href="../../bower_components/paper-material/paper-material.html">
<link rel="import" href="../../bower_components/sm3-resizable/sm3-resizable.html">
<link rel="import" href="../../styles/shared-styles.html">
<link rel="import" href="../imports/dagre-d3.html">

<dom-module id="automata-visualisation">
  <style include="shared-styles"></style>
  <style>
    :host {
      font-family: "Helvetica Neue", Helvetica, Arial, sans-serf;
      color: #6C7A89;
    }
    sm3-resizable {
      width: 100% !important;
      height: var(--automata-visualisation-height);
      min-height: var(--automata-visualisation-min-height);
      --sm3-resizable-handle-s: {
        bottom: 0;
        left: 8px;
        right: 8px;
        height: 16px;
      };
    }
    paper-material {
      @apply(--layout-fit);
    }
    #svg-parent{
      @apply(--layout-fit);
      margin: 4px 4px 4px 4px;
    }
    #svg{
      width: 100%;
      height: 100%;
    }
    #name{
      position: absolute;
      top: 8px;
      left: 8px;
      color: red;
      font-size: 12pt;
      @apply(--automata-visualisation-name-style);
    }
    .node circle.outer{
      fill: var(--node-fill, #DADEDF);
      stroke: var(--node-stroke, #000000);
      stroke-width: var(--node-stroke-width, 2px);
    }
    .node circle.inner{
      fill: transparent;
      stroke: transparent;
    }
    .node .label {
      color: var(--node-label-color, #000000);
    }
    .node.start{
      transform: scale(0);
      display: none;
    }
    .node.start .label {
      color: var(--start-node-label-color, #000000);
    }
    .node.terminal circle.inner{
      stroke: var(--node-stroke, #000000);
      stroke-width: var(--terminal-node-outer-stroke-width, 2px);
      stroke-width: var(--terminal-node-inner-stroke-width, 1.5px);
    }
    .node.terminal .label {

    }
    .node.stop circle.outer{
      fill: var(--stop-node-fill);
      stroke: var(--stop-node-stroke, #00FF00);
      stroke-width: var(--stop-node-stroke-width);
    }
    .node.stop circle.inner{
      stroke: var(--stop-node-stroke, #00BB00);
      stroke-width: var(--stop-node-stroke-width);
    }
    .node.stop .label {
      color: var(--stop-node-label-color, #000000);
    }
    .node.error circle.outer{
      fill: var(--error-node-fill);
      stroke: var(--error-node-stroke, #FF0000);
      stroke-width: var(--error-node-stroke-width);
    }
    .node.error circle.inner{
      stroke: var(--error-node-stroke, #FF0000);
      stroke-width: var(--error-node-stroke-width);
    }
    .node.error .label {
      color: var(--error-node-label-color, #000000);
    }
    .node.reference circle.outer{
      fill: var(--reference-node-fill, #FFFF66);
      stroke: var(--reference-node-stroke);
      stroke-width: var(--reference-node-stroke-width);
    }
    .node.highlighted circle.outer{
      fill: var(--node-highlighted-fill, #4488FF);
    }
    .edgePath path {
      fill: var(--edge-fill, #000000);
      stroke: var(--edge-stroke, #000000);
      stroke-width: var(--edge-stroke-width, 1.5px);
    }
    .edgeLabel {
      fill: var(--edge-label-color, #000000);
    }
    /*.edgePath defs marker path{
      fill: #8F939E;
    }*/
  </style>
  <template>
    <sm3-resizable id="resizer" handle-s on-sm3-resizable-resized="onResize">
      <paper-material>
        <div id="svg-parent">
          <svg id="svg"></svg>
        </div>
        <div id="name">[[name]]</div>
      </paper-material>
    </sm3-resizable>
  </template>
</dom-module>

<script>
  (function() {
    'use strict';

    Polymer({
      is: 'automata-visualisation',

      properties: {
        /**
        * The name of the automaton.
        */
        name: {
          type: String,
          value: 'Unnamed Automaton'
        },

        /**
        * The array of nodes to draw.
        * A node is a Object with a unquie 'id' field and a 'label' field
        */
        nodes: {
          type: Array,
          value: []
        },

        /**
        * The array of edges to draw.
        * An edge is a Object that has a 'from' and a 'to' field specifying the nodes it connects.
        * It may also have a 'label' field (if no label is given, epsilon (ε) will be used)
        */
        edges: {
          type: Array,
          value: []
        },

        /**
         * The graph that is rendered.
         */
        automaton: Object,

        /**
         * The id of the highlighted node.
         */
        _highlightedNodeId: Number
      },

      ready: function() {
        // mark the svg element as a scoped subtree so that dom modification by dagreD3 are styled correctly
        this.scopeSubtree(this.$.svg, true);

        // draw the automaton - but wait until everything else is setup first
        this.async(function() {
          this.redraw();
        });
      },

      /**
       * Called when `#resizer` is resized
       */
      onResize: function() {
        this.debounce('automata-visualisation-resize', function() {
          var svg = d3.select(this.$.svg);
          var svgGroup = svg.select('g');
          this._center(svg, svgGroup);
        }, 300);
      },

      /**
       * Highlight the specified node in the specified automaton.
       */
      setHighlightNodeId: function(id) {
        this._highlightedNodeId = id;
        Polymer.dom(this.$.svg).querySelectorAll('.highlighted').forEach(function(n) {
          n.classList.remove('highlighted');
        });
        Polymer.dom(this.$.svg).querySelector('.n'+id).classList.add('highlighted');
      },

      /**
       * Redraw the automaton.
       */
      redraw: function() {
        // remove the child nodes (the old graph) from the svg element
        for(var i=0; i<this.$.svg.children.length; i++){
          Polymer.dom(this.$.svg).removeChild(this.$.svg.children[i]);
        }

        // create a new directed graph
        this.automaton = new dagreD3.graphlib.Graph({ multigraph: true });
        this.automaton.setGraph({
          rankdir: 'LR',
          marginx: 0,
          marginy: 0
        });

        /*
         * Note:
         * dagreD3 sorts the nodes given to it alphabetically then the root node is
         * concider to be first node after this sorting.
         *
         * In order to specifie the actual start node, create a node that will be
         * first after sorting then create a edge from it to the "visual" start node
         */

        // this is the node in `this.nodes` that is marked as the start node
        var visualStartNode;

        // create the actual start node
        this.automaton.setNode('0', { label: '', shape: 'circle', class: 'start' });

        // add the nodes to the graph
        this.nodes.forEach(function(node) {
          // the classes for this node
          var styleClasses = 'n' + node.id;

          if (node.getMetaData('startNode')) {
            visualStartNode = node;
          }

          var terminal = node.getMetaData('isTerminal');
          if (terminal) {
            styleClasses += ' terminal ' + terminal;
          }

          var ref = node.getMetaData('references');
          if (ref && ref !== this.name) {
            styleClasses += ' reference';
          }

          // add the node to the graph
          this.automaton.setNode('n' + node.id, { label: node.label, shape: 'automatonnode', class: styleClasses.trim() });
        }.bind(this));

        // Default to assigning a new object as a label for each new edge.
        this.automaton.setDefaultEdgeLabel(function() {
          return {};
        });

        // create an edge from the actual start node to the visual start node
        this.automaton.setEdge('0', 'n'+visualStartNode.id, { label: '', lineInterpolate: 'basis' }, 'startEdge');

        // add the edges to the graph
        //  - the from node's label
        //  - the to node's label
        //  - the edge's extra data (could be label, width, height, etc.)
        this.edges.forEach(function(edge) {
          var label = edge.label || 'ε';
          if (edge.isHidden) {
            label = '𝜏';
          }
          if (edge.isDeadlock) {
            label = '𝛿';
          }
          // add the edge to the graph
          this.automaton.setEdge('n'+edge.from.id, 'n'+edge.to.id, { label: label, lineInterpolate: 'basis' }, edge.id);
        }.bind(this));

        var svg = d3.select(this.$.svg);
        var svgGroup = svg.append('g');       // add a new group node to the svg element for the new graph
        var render = this._createRender();    // create the render

        // run the renderer, which will draw the graph and insert it into the svgGroup.
        // Note: trying call render method with a node (first arg) that is not yet in the Dom will cause an error
        render(svgGroup, this.automaton);

        // remove the svg element and then put it back in properly
        // (otherwise thing like shady dom css cannot be applied)
        // var svgParent = Polymer.dom(this.$.svg).parentNode;
        // Polymer.dom(svgParent).appendChild(Polymer.dom(svgParent).removeChild(this.$.svg));

        // Do zoom - center
        this._center(svg, svgGroup);

        this.fire('automata-visualisation-rendered');
      },

      /**
       * Create a dagreD3 render.
       */
      _createRender: function() {
        var render = new dagreD3.render();    // create the renderer

        // define the 'automatonnode' shape
        render.shapes().automatonnode = function(parent, bbox, node) {
          var r = 22.5;

          parent.insert('circle', ':first-child')
            .attr('r', r * 0.80)
            .attr('class', 'inner')
            .attr('transform', 'translate(0,0)');

          var shapeSvg = parent.insert('circle', ':first-child')
            .attr('r', r)
            .attr('class', 'outer')
            .attr('transform', 'translate(0,0)');

          node.intersect = function(point) {
            return dagreD3.intersect.circle(node, r, point);
          };

          return shapeSvg;
        };

        return render;
      },

      _center: function(svg, svgGroup) {

        // Get the SVG's attrs as well as the automaton's attrs
        var svgStyle = window.getComputedStyle(svg[0][0]),
            svgWidth = parseFloat(svgStyle.getPropertyValue('width')),
            svgHeight = parseFloat(svgStyle.getPropertyValue('height')),
            automatonWidth = this.automaton.graph().width,
            automatonHeight = this.automaton.graph().height;

        //  By default, set the scale to this value
        var defaultInitialScale = 1.5;

        // Compute the scale where the automaton will fit
        var computedInitialScaleForWitdth = svgWidth / (automatonWidth * 1.1),
            computedInitialScaleForHeight = svgHeight / (automatonHeight * 1.1),
            computedInitialScale = Math.min(computedInitialScaleForHeight, computedInitialScaleForWitdth);

        // Choose the scale which is smaller, such that we ensure the entire automaton is viewable
        var initialScale = Math.min(defaultInitialScale, computedInitialScale);

        // limit the zoom and pan behaviour
        var zoom = d3.behavior.zoom().scaleExtent([0.5, 5]).on('zoom', function() {
          // the raw translate value [x, y] from the mouse coords
          var t = d3.event.translate;
          // set our modified scale to reflect the initial scale in addition to the user's scale changes
          var s = initialScale + d3.event.scale - 1;

          // the maximum left value
          var txl = Math.max(0, Math.min(svgWidth - this.automaton.graph().width * s, t[0]));
          // the maximum right value
          var txr = Math.min(svgWidth - this.automaton.graph().width * s , Math.max(0, t[0]));
          // the ultimate x value, souch that it is bounded to txl and txr
          var tx = Math.min(txl, Math.max(txr, t[0]));

          // the maximum top value
          var tyl = Math.max(0, Math.min(svgHeight - this.automaton.graph().height * s, t[1]));
          // the maximum bottom value
          var tyr = Math.min(svgHeight - this.automaton.graph().height * s , Math.max(0, t[1]));
          // the ultimate y value, souch that it is bounded to txl and txr
          var ty = Math.min(tyl, Math.max(tyr, t[1]));

          // the ultimate translation array, bounded
          var boundedTranslate = [tx, ty];

          //scale and translate
          svgGroup.attr('transform',
            'translate(' + boundedTranslate[0] + ',' + boundedTranslate[1] + ')' +
            'scale(' + s + ')');
        }.bind(this));
        // Update the svg such that it's events call our bounding function
        svg.call(zoom);

        // Calculate the offsets required to be in center
        var xCenterOffset = (svgWidth - this.automaton.graph().width * initialScale) / 2;
        var yCenterOffset = (svgHeight - this.automaton.graph().height * initialScale) / 2;

        // Center the graph
        zoom.translate([ xCenterOffset, yCenterOffset]).event(svg);

        // Center the labels in the nodes
        var nodeLabels = svg[0][0].querySelectorAll('g.node g.label g text tspan');
        for(var j=0; j<nodeLabels.length; j++){
          nodeLabels[j].setAttribute('x', '0');
          nodeLabels[j].setAttribute('dy', '0.9em');
        }

      }

    });
  })();
</script>
